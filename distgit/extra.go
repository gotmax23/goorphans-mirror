package distgit

import (
	"errors"
	"fmt"
	"log"
	"net/http"
	"net/url"

	"go.gtmx.me/goorphans/common"
)

var DefaultBaseURL = common.Must(url.Parse("https://src.fedoraproject.org"))

// ExtrasClient wraps the data files located under [DefaultBaseURL] + /extras.
type ExtrasClient struct {
	Client  *http.Client
	BaseURL *url.URL
}

func NewExtrasClient(client *http.Client) *ExtrasClient {
	if client == nil {
		client = &http.Client{}
	}
	return &ExtrasClient{Client: client, BaseURL: DefaultBaseURL}
}

func (c *ExtrasClient) get(dest any, file string) error {
	return common.GetJSON(
		c.Client,
		dest,
		c.BaseURL.JoinPath("extras", fmt.Sprintf("%s.json", file)),
	)
}

// ExtrasPagureBZ represents the data available at
// https://src.fedoraproject.org/extras/pagure_bz.json that's generated by
// https://pagure.io/pagure-dist-git/blob/master/f/scripts/pagure_bz.py. It
// includes any user with permissions on a project (admin, commit, ticket), any
// groups with permissions (group names are prefixed with "@"), and any
// watchers.
type ExtrasPagureBZ struct {
	Container map[string][]string `json:"container"`
	Flatpaks  map[string][]string `json:"flatpaks"`
	Modules   map[string][]string `json:"modules"`
	RPMS      map[string][]string `json:"rpms"`
	Tests     map[string][]string `json:"tests"`
}

func (c *ExtrasClient) GetPagureBZ() (*ExtrasPagureBZ, error) {
	var d ExtrasPagureBZ
	return &d, c.get(&d, "pagure_bz")
}

// ExtrasPagureOwnerAlias represents the data available at
// https://src.fedoraproject.org/extras/pagure_owner_alias.json that's generated by
// https://pagure.io/pagure-dist-git/blob/master/f/scripts/pagure_owner_alias.py.
// It includes all users (not groups) with admin or commit.
type ExtrasPagureOwnerAlias struct {
	Container map[string][]string `json:"container"`
	Flatpaks  map[string][]string `json:"flatpaks"`
	Modules   map[string][]string `json:"modules"`
	RPMS      map[string][]string `json:"rpms"`
	Tests     map[string][]string `json:"tests"`
}

func (c *ExtrasClient) GetPagureOwnerAlias() (*ExtrasPagureOwnerAlias, error) {
	var d ExtrasPagureOwnerAlias
	return &d, c.get(&d, "pagure_owner_alias")
}

// ExtrasPagurePOC represents the data available at
// https://src.fedoraproject.org/extras/pagure_poc.json that's generated by
// https://pagure.io/pagure-dist-git/blob/master/f/scripts/pagure_poc.py.
// It includes the package admins and the Bugzilla assignes for "Fedora" and "FedoraEPEL".
type ExtrasPagurePOC struct {
	Container map[string]ExtrasPagurePOCTypes `json:"container"`
	Flatpaks  map[string]ExtrasPagurePOCTypes `json:"flatpaks"`
	Modules   map[string]ExtrasPagurePOCTypes `json:"modules"`
	RPMS      map[string]ExtrasPagurePOCTypes `json:"rpms"`
	Tests     map[string]ExtrasPagurePOCTypes `json:"tests"`
}

type ExtrasPagurePOCTypes struct {
	Admin  string `json:"admin"`
	EPEL   string `json:"epel"`
	Fedora string `json:"fedora"`
}

func (c *ExtrasClient) GetPagurePOC() (*ExtrasPagurePOC, error) {
	var d ExtrasPagurePOC
	return &d, c.get(&d, "pagure_poc")
}

func (c *ExtrasClient) GetRetiredIn(release string) ([]string, error) {
	u := c.BaseURL.JoinPath("lookaside", fmt.Sprintf("retired_in_%s.json", release))
	d := map[string][]string{}
	err := common.GetJSON(c.Client, d, u)
	if err != nil {
		return nil, err
	}
	return d[release], nil
}

// IsRetired ...
// TODO: Use Koji API or some other way to check this that doesn't hit Pagure
// * the https://src.fedoraproject.org/lookaside/.retired_in_BRANCH.json files were incomplete.
// * using the Koji API is more complicated
func (c *ExtrasClient) IsRetired(name string, branch string) (bool, error) {
	baseerr := fmt.Errorf("failed to check if package %s is retired on %s", name, branch)
	// e.g., https://src.fedoraproject.org/rpms/python38-toml-epel/raw/rawhide/f/dead.package
	u := c.BaseURL.JoinPath("rpms", name, "raw", branch, "f/dead.package").String()
	req, _ := http.NewRequest(http.MethodGet, u, nil)
	req.Header.Set("User-Agent", "go.gtmx.me/goorphans")
	req.Header.Set("Accept", "text/plain")
	log.Printf("GET %s", u)
	resp, err := c.Client.Do(req)
	if err != nil {
		return false, errors.Join(baseerr, err)
	}
	defer resp.Body.Close()
	switch resp.StatusCode {
	case http.StatusOK:
		return true, nil
	case http.StatusNotFound:
		return false, nil
	default:
		return false, errors.Join(baseerr, common.CheckStatusCode(resp))
	}
}
